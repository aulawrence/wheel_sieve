"""Elliptic Curve Method with Brent-Suyama Extension.
"""
import random
import time
from math import gcd
import numpy as np
from wheel_sieve.common import (
    PRIME_GEN,
    InverseNotFound,
    CurveInitFail,
    init_wheel,
    inv,
    inv_multi,
)
import wheel_sieve.ecm.ecm_montgomery as mnt
import wheel_sieve.ecm.ecm_weierstrass as wst


def apply_polynomial(coeff, x):
    """Given coefficients [a0, a1, ..., an] and x, compute f(x) = a0 + a1*x + ... + ai*x**i + ... an*x**n.

    Args:
        coeff (list of int): Coefficients [a0, a1, ..., an].
        x (int): Point x to on which to evaluate the polynomial.

    Returns:
        int: f(x) = a0 + a1*x + ... + ai*x**i + ... an*x**n.
    """
    f = 0
    xi = 1
    for ai in coeff:
        f += ai * xi
        xi *= x
    return f


def get_difference_seq(coeff, x0, d):
    """Given coefficients [a0, a1, ..., an], x0 and d, compute [d0, d1, ..., dn] where di is the first
    term of the i-th order difference sequence of {f(x0), f(x0+d), f(x0+2d), ...}.
    With this sequence, we can compute {f(x0), f(x0+d), f(x0+2d), ...} sequentially using n-1 additions
    for each term.

    Args:
        coeff (list of int): Coefficients [a0, a1, ..., an].
        x0 (int): Initial value of the arithmetic sequence {x0, x0+d, ...}.
        d (int): Common difference of the arithmetic sequence {x0, x0+d, ...}.

    Returns:
        list of int: [d0, d1, ..., dn] where di is the first term of the i-th order difference sequence of
            {f(x0), f(x0+d), f(x0+2d), ...}.
    """
    n = len(coeff)
    f = [apply_polynomial(coeff, x) for x in range(x0, x0 + n * d, d)]
    for i in range(1, n):
        for j in range(n - 1, i - 1, -1):
            f[j] -= f[j - 1]
    return f


def step_difference_seq_exn(pt_list, curve):
    """Compute 1 step forward on the points generated by a difference sequence. Modifies pt_list in place.
    Uses Montgomery's trick so that it takes only 1 modular inversion instead of len(pt_list) - 1.

    Raises:
        InverseNotFound: Thrown when a term necessary for the calculation cannot be inverted.

    Args:
        pt_list (list of point): List of points in XY form.
        curve (curve): Curve in Weierstrass form.
    """
    a, b, n = curve
    gen_list = [
        wst.add_pt_gen(pt_list[i], pt_list[i + 1], curve)
        for i in range(len(pt_list) - 1)
    ]
    denom_list = [gen.send(None) for gen in gen_list]
    denom_set = set()
    for denom in denom_list:
        if denom is not None:
            denom_set.add(denom)
    if denom_set:
        denom_inv_dict = inv_multi(list(denom_set), n)
    for i in range(len(pt_list) - 1):
        if denom_list[i] is None:
            pt_list[i] = gen_list[i].send(None)
        else:
            pt_list[i] = gen_list[i].send(denom_inv_dict[denom_list[i]])


def ecm(n, rounds, b1, b2):
    """Elliptic Curve Factorization Method.
    For each round:
        0. Generate random point and curve.
        1. Repeatedly multiply the current point by small primes raised to some power, determined by b1.
        2. Standard continuation on primes from b1 to b2 with Brent-Suyama's Extension.
    Returns when a non-trivial factor is found.

    Args:
        n (int): Number to be factorized. n >= 12.
        rounds (int): Number of random curves to try.
        b1 (int): Bound for primes used in step 1.
        b2 (int): Bound for primes searched for in step 2. b1 < b2.

    Returns:
        int: Non-trivial factor if found, otherwise returns None.
    """
    assert n >= 12
    wheel = 2310
    st = time.time()
    j_list, prime_array = init_wheel(b1, b2, wheel)
    print("Init time: {:.2f}".format(time.time() - st))
    for round_i in range(rounds):
        st = time.time()
        print("Round {}...".format(round_i))
        count = 0
        success = False
        while not success and count < 20:
            try:
                count += 1
                sigma = random.randint(6, n - 6)
                mnt_pt, mnt_curve = mnt.get_curve_suyama(sigma, n)
                success = True
            except InverseNotFound as e:
                res = gcd(e.x, n)
                if 1 < res < n:
                    return res
            except CurveInitFail:
                pass
        if not success:
            print(" - Curve Init Failed.")
            break
        try:
            # Step 1
            print("{:>5.2f}: Step 1".format(time.time() - st))
            for p in PRIME_GEN(b1):
                for _ in range(int(np.log(b1) / np.log(p))):
                    mnt_pt = mnt.mul_pt_exn(mnt_pt, mnt_curve, p)
            # Step 2
            print("{:>5.2f}: Step 2".format(time.time() - st))
            polynomial = (2, 0, 9, 0, 6, 0, 1)  # f(x) = x^6 + 6x^4 + 9x^2 + 2
            q, wst_curve = mnt.to_weierstrass(mnt_pt, mnt_curve)
            c1 = b1 // wheel
            c2 = b2 // wheel + 2
            c = 0
            k_ls = [
                apply_polynomial(polynomial, j) for j in j_list
            ] + get_difference_seq(polynomial, c1 * wheel, wheel)
            mul_res = wst.mul_pt_multi(q, wst_curve, k_ls)
            xj_list = []
            for i in range(len(j_list)):
                xj_list.append(mul_res[i][0])
            cq_list = mul_res[len(j_list) :]
            while c < c2 - c1:
                # assert cq_list[0] == wst.mul_pt_exn(q, wst_curve, apply_polynomial(polynomial, (c + c1) * wheel))
                s = cq_list[0][1] if cq_list[0][1] != 0 else 1
                for xj, is_prime in zip(
                    xj_list, np.unpackbits(prime_array[c, :], bitorder="little")
                ):
                    if is_prime:
                        t = (cq_list[0][0] - xj) % n
                        if t != 0:
                            s = s * t % n
                res = gcd(s, n)
                if 1 < res < n:
                    return res
                elif res == n:
                    res = gcd(cq_list[0][1], n)
                    if 1 < res < n:
                        return res
                    for xj in xj_list:
                        res = gcd(cq_list[0][0] - xj, n)
                        if 1 < res < n:
                            return res
                    # s is a multiple of n while each of cq_list[0][1] and {(cq_list[0][0] - xj) % n} is not.
                    # There must be at least 2 non-trivial factors. The function should have returned.
                    assert False
                c += 1
                step_difference_seq_exn(cq_list, wst_curve)
            print("{:>5.2f}: End".format(time.time() - st))
        except InverseNotFound as e:
            res = gcd(e.x, n)
            if 1 < res < n:
                return res
    return None


if __name__ == "__main__":
    random.seed(2)
    n = 294636370796972331405770334382449402989049465216208991677129  # (406724252548875212358759885439 * 724413085648406196306771670711)
    print(ecm(n, 430, 250_000, 40_000_000))
